"use strict";(globalThis.webpackChunkcpp_algorithm_snippets=globalThis.webpackChunkcpp_algorithm_snippets||[]).push([[551],{597:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>a,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"c-cpp/working-with-128-bit-integers","title":"Working with 128-bit Integers in C++","description":"What this code does (short)","source":"@site/docs/c-cpp/working-with-128-bit-integers.md","sourceDirName":"c-cpp","slug":"/c-cpp/working-with-128-bit-integers","permalink":"/cpp-algorithm-snippets/docs/c-cpp/working-with-128-bit-integers","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/c-cpp/working-with-128-bit-integers.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Working with 128-bit Integers in C++","sidebar_label":"Working with 128-bit Integers"},"sidebar":"tutorialSidebar","previous":{"title":"Measuring Execution Time","permalink":"/cpp-algorithm-snippets/docs/c-cpp/measuring-execution-time"},"next":{"title":"Math","permalink":"/cpp-algorithm-snippets/docs/category/math"}}');var t=i(4848),r=i(8453);const o={sidebar_position:4,title:"Working with 128-bit Integers in C++",sidebar_label:"Working with 128-bit Integers"},c=void 0,d={},l=[{value:"What this code does (short)",id:"what-this-code-does-short",level:2},{value:"Line-by-line explanation",id:"line-by-line-explanation",level:2},{value:"Input operator: <code>operator &gt;&gt;</code>",id:"input-operator-operator-",level:3},{value:"Output operator: <code>operator &lt;&lt;</code>",id:"output-operator-operator-",level:3},{value:"How to use",id:"how-to-use",level:2}];function h(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"what-this-code-does-short",children:"What this code does (short)"}),"\n",(0,t.jsxs)(n.p,{children:["The code defines a 128-bit integer type for GNU C++ (",(0,t.jsx)(n.code,{children:"__int128"}),") and provides two stream operators so you can use ",(0,t.jsx)(n.code,{children:"cin >>"})," and ",(0,t.jsx)(n.code,{children:"cout <<"})," with that type. This is useful because the standard iostream library does not know how to read or print ",(0,t.jsx)(n.code,{children:"__int128"}),"."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"line-by-line-explanation",children:"Line-by-line explanation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// for: GNU C++20 (64)\nusing i128 = __int128;\nconst i128 ONE_128 = i128(1);\nconst i128 ZERO_128 = i128(0);\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"using i128 = __int128;"})," creates an alias ",(0,t.jsx)(n.code,{children:"i128"})," for the builtin GNU type ",(0,t.jsx)(n.code,{children:"__int128"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"__int128"})," is a 128-bit signed integer available in GNU compilers on 64-bit systems. It stores much bigger values than ",(0,t.jsx)(n.code,{children:"long long"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["These two lines define constants ",(0,t.jsx)(n.code,{children:"ONE_128"})," and ",(0,t.jsx)(n.code,{children:"ZERO_128"})," with values ",(0,t.jsx)(n.code,{children:"1"})," and ",(0,t.jsx)(n.code,{children:"0"})," typed as ",(0,t.jsx)(n.code,{children:"i128"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"They make the code clearer when you need literal 128-bit constants."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"input-operator-operator-",children:["Input operator: ",(0,t.jsx)(n.code,{children:"operator >>"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"std::istream &operator>>(std::istream &is, i128 &n) {\n    n = 0;\n    std::string s; is >> s;\n    for (auto c : s) {\n        n = 10 * n + c - '0';\n    }\n    return is;\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["This overload lets you write ",(0,t.jsx)(n.code,{children:"cin >> my_i128_variable;"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Steps it performs:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Set ",(0,t.jsx)(n.code,{children:"n"})," to zero."]}),"\n",(0,t.jsxs)(n.li,{children:["Read the whole token from the stream into a ",(0,t.jsx)(n.code,{children:"std::string s"}),". This skips leading whitespace and reads until the next whitespace."]}),"\n",(0,t.jsxs)(n.li,{children:["For each character ",(0,t.jsx)(n.code,{children:"c"})," in the string, it updates ",(0,t.jsx)(n.code,{children:"n = 10*n + (c - '0')"}),". That converts the decimal digits to a numeric value."]}),"\n",(0,t.jsxs)(n.li,{children:["Return the input stream reference so chaining (e.g., ",(0,t.jsx)(n.code,{children:"cin >> a >> b;"}),") works."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Important limitations"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The code assumes the string contains only digits (",(0,t.jsx)(n.code,{children:"'0'"}),"\u2013",(0,t.jsx)(n.code,{children:"'9'"}),"). It does ",(0,t.jsx)(n.strong,{children:"not"})," handle a leading ",(0,t.jsx)(n.code,{children:"-"})," sign, a leading ",(0,t.jsx)(n.code,{children:"+"}),", or invalid characters."]}),"\n",(0,t.jsx)(n.li,{children:"It does not check for overflow. If the number in the input is larger than 128 bits can hold, the behavior is undefined (it will wrap or give wrong results)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"output-operator-operator-",children:["Output operator: ",(0,t.jsx)(n.code,{children:"operator <<"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"std::ostream &operator<<(std::ostream &os, i128 n) {\n    if (n == 0) {\n        return os << 0;\n    }\n    std::string s;\n    while (n > 0) {\n        s += '0' + n % 10;\n        n /= 10;\n    }\n    std::reverse(s.begin(), s.end());\n    return os << s;\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["This overload lets you write ",(0,t.jsx)(n.code,{children:"cout << my_i128_variable;"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Steps it performs:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"n"})," is zero, it prints ",(0,t.jsx)(n.code,{children:"0"})," and returns."]}),"\n",(0,t.jsxs)(n.li,{children:["Otherwise it builds a string ",(0,t.jsx)(n.code,{children:"s"})," with the digits of ",(0,t.jsx)(n.code,{children:"n"})," in reverse order: take ",(0,t.jsx)(n.code,{children:"n % 10"})," to get the last digit, append the corresponding character, and then divide ",(0,t.jsx)(n.code,{children:"n"})," by 10."]}),"\n",(0,t.jsx)(n.li,{children:"Reverse the string to get the correct digit order."}),"\n",(0,t.jsx)(n.li,{children:"Output the string and return the stream."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u26a0\ufe0f Warning:"}),"\n",(0,t.jsxs)(n.em,{children:["The provided code only works correctly for ",(0,t.jsx)(n.strong,{children:"positive integers"}),". It does ",(0,t.jsx)(n.strong,{children:"not"})," support negative numbers or the sign ",(0,t.jsx)(n.code,{children:"-"}),", and printing a negative ",(0,t.jsx)(n.code,{children:"i128"})," will also produce incorrect output."]})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Important limitations"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The code assumes ",(0,t.jsx)(n.code,{children:"n"})," is non-negative. If ",(0,t.jsx)(n.code,{children:"n"})," is negative, the ",(0,t.jsx)(n.code,{children:"while (n > 0)"})," loop never runs and the result is wrong. Typical fix: check ",(0,t.jsx)(n.code,{children:"if (n < 0) { os << '-'; n = -n; }"})," before converting digits."]}),"\n",(0,t.jsx)(n.li,{children:"Converting a 128-bit integer to decimal takes time proportional to the number of digits (about 39 digits max for 128-bit), which is fine for competitive programming."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"how-to-use",children:"How to use"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"i128 a;\ncin >> a;\ncout << a << '\\n';\n"})})]})}function a(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>c});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);